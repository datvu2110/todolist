{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define([\"require\", \"exports\", \"./ColorUtils\", \"./NumberUtils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.CanvasUtils = void 0;\n\n  const ColorUtils_1 = require(\"./ColorUtils\");\n\n  const NumberUtils_1 = require(\"./NumberUtils\");\n\n  function drawLine(context, begin, end) {\n    context.beginPath();\n    context.moveTo(begin.x, begin.y);\n    context.lineTo(end.x, end.y);\n    context.closePath();\n  }\n\n  function drawTriangle(context, p1, p2, p3) {\n    context.beginPath();\n    context.moveTo(p1.x, p1.y);\n    context.lineTo(p2.x, p2.y);\n    context.lineTo(p3.x, p3.y);\n    context.closePath();\n  }\n\n  class CanvasUtils {\n    static paintBase(context, dimension, baseColor) {\n      context.save();\n      context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n      context.fillRect(0, 0, dimension.width, dimension.height);\n      context.restore();\n    }\n\n    static clear(context, dimension) {\n      context.clearRect(0, 0, dimension.width, dimension.height);\n    }\n\n    static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n      let drawn = false;\n\n      if (NumberUtils_1.NumberUtils.getDistance(begin, end) <= maxDistance) {\n        drawLine(context, begin, end);\n        drawn = true;\n      } else if (warp) {\n        let pi1;\n        let pi2;\n        const endNE = {\n          x: end.x - canvasSize.width,\n          y: end.y\n        };\n        const d1 = NumberUtils_1.NumberUtils.getDistances(begin, endNE);\n\n        if (d1.distance <= maxDistance) {\n          const yi = begin.y - d1.dy / d1.dx * begin.x;\n          pi1 = {\n            x: 0,\n            y: yi\n          };\n          pi2 = {\n            x: canvasSize.width,\n            y: yi\n          };\n        } else {\n          const endSW = {\n            x: end.x,\n            y: end.y - canvasSize.height\n          };\n          const d2 = NumberUtils_1.NumberUtils.getDistances(begin, endSW);\n\n          if (d2.distance <= maxDistance) {\n            const yi = begin.y - d2.dy / d2.dx * begin.x;\n            const xi = -yi / (d2.dy / d2.dx);\n            pi1 = {\n              x: xi,\n              y: 0\n            };\n            pi2 = {\n              x: xi,\n              y: canvasSize.height\n            };\n          } else {\n            const endSE = {\n              x: end.x - canvasSize.width,\n              y: end.y - canvasSize.height\n            };\n            const d3 = NumberUtils_1.NumberUtils.getDistances(begin, endSE);\n\n            if (d3.distance <= maxDistance) {\n              const yi = begin.y - d3.dy / d3.dx * begin.x;\n              const xi = -yi / (d3.dy / d3.dx);\n              pi1 = {\n                x: xi,\n                y: yi\n              };\n              pi2 = {\n                x: pi1.x + canvasSize.width,\n                y: pi1.y + canvasSize.height\n              };\n            }\n          }\n        }\n\n        if (pi1 && pi2) {\n          drawLine(context, begin, pi1);\n          drawLine(context, end, pi2);\n          drawn = true;\n        }\n      }\n\n      if (!drawn) {\n        return;\n      }\n\n      context.lineWidth = width;\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n      }\n\n      context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n\n      if (shadow.enable) {\n        const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n\n        if (shadowColor) {\n          context.shadowBlur = shadow.blur;\n          context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n        }\n      }\n\n      context.stroke();\n    }\n\n    static drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n      drawTriangle(context, pos1, pos2, pos3);\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n      }\n\n      context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n      context.fill();\n    }\n\n    static drawConnectLine(context, width, lineStyle, begin, end) {\n      context.save();\n      drawLine(context, begin, end);\n      context.lineWidth = width;\n      context.strokeStyle = lineStyle;\n      context.stroke();\n      context.restore();\n    }\n\n    static gradient(context, p1, p2, opacity) {\n      const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n      const color1 = p1.getFillColor();\n      const color2 = p2.getFillColor();\n\n      if (!color1 || !color2) {\n        return;\n      }\n\n      const sourcePos = p1.getPosition();\n      const destPos = p2.getPosition();\n      const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.getRadius(), p2.getRadius());\n      const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n      grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n      grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n      grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n      return grad;\n    }\n\n    static drawGrabLine(context, width, begin, end, colorLine, opacity) {\n      context.save();\n      drawLine(context, begin, end);\n      context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n      context.lineWidth = width;\n      context.stroke();\n      context.restore();\n    }\n\n    static drawLight(container, context, mousePos) {\n      const lightOptions = container.options.interactivity.modes.light.area;\n      context.beginPath();\n      context.arc(mousePos.x, mousePos.y, lightOptions.radius, 0, 2 * Math.PI);\n      const gradientAmbientLight = context.createRadialGradient(mousePos.x, mousePos.y, 0, mousePos.x, mousePos.y, lightOptions.radius);\n      const gradient = lightOptions.gradient;\n      const gradientRgb = {\n        start: ColorUtils_1.ColorUtils.colorToRgb(gradient.start),\n        stop: ColorUtils_1.ColorUtils.colorToRgb(gradient.stop)\n      };\n\n      if (!gradientRgb.start || !gradientRgb.stop) {\n        return;\n      }\n\n      gradientAmbientLight.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.start));\n      gradientAmbientLight.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.stop));\n      context.fillStyle = gradientAmbientLight;\n      context.fill();\n    }\n\n    static drawParticleShadow(container, context, particle, mousePos) {\n      const pos = particle.getPosition();\n      const shadowOptions = container.options.interactivity.modes.light.shadow;\n      context.save();\n      const radius = particle.getRadius();\n      const sides = particle.sides;\n      const full = Math.PI * 2 / sides;\n      const angle = -particle.rotate.value + Math.PI / 4;\n      const factor = 1;\n      const dots = [];\n\n      for (let i = 0; i < sides; i++) {\n        dots.push({\n          x: pos.x + radius * Math.sin(angle + full * i) * factor,\n          y: pos.y + radius * Math.cos(angle + full * i) * factor\n        });\n      }\n\n      const points = [];\n      const shadowLength = shadowOptions.length;\n\n      for (const dot of dots) {\n        const dotAngle = Math.atan2(mousePos.y - dot.y, mousePos.x - dot.x);\n        const endX = dot.x + shadowLength * Math.sin(-dotAngle - Math.PI / 2);\n        const endY = dot.y + shadowLength * Math.cos(-dotAngle - Math.PI / 2);\n        points.push({\n          endX: endX,\n          endY: endY,\n          startX: dot.x,\n          startY: dot.y\n        });\n      }\n\n      const shadowRgb = ColorUtils_1.ColorUtils.colorToRgb(shadowOptions.color);\n\n      if (!shadowRgb) {\n        return;\n      }\n\n      const shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowRgb);\n\n      for (let i = points.length - 1; i >= 0; i--) {\n        const n = i == points.length - 1 ? 0 : i + 1;\n        context.beginPath();\n        context.moveTo(points[i].startX, points[i].startY);\n        context.lineTo(points[n].startX, points[n].startY);\n        context.lineTo(points[n].endX, points[n].endY);\n        context.lineTo(points[i].endX, points[i].endY);\n        context.fillStyle = shadowColor;\n        context.fill();\n      }\n\n      context.restore();\n    }\n\n    static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow) {\n      const pos = particle.getPosition();\n      context.save();\n      context.translate(pos.x, pos.y);\n      context.beginPath();\n      const angle = particle.rotate.value + (particle.particlesOptions.rotate.path ? particle.pathAngle : 0);\n\n      if (angle !== 0) {\n        context.rotate(angle);\n      }\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n      }\n\n      const shadowColor = particle.shadowColor;\n\n      if (shadow.enable && shadowColor) {\n        context.shadowBlur = shadow.blur;\n        context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n        context.shadowOffsetX = shadow.offset.x;\n        context.shadowOffsetY = shadow.offset.y;\n      }\n\n      if (fillColorValue) {\n        context.fillStyle = fillColorValue;\n      }\n\n      const stroke = particle.stroke;\n      context.lineWidth = particle.strokeWidth;\n\n      if (strokeColorValue) {\n        context.strokeStyle = strokeColorValue;\n      }\n\n      CanvasUtils.drawShape(container, context, particle, radius, opacity, delta);\n\n      if (stroke.width > 0) {\n        context.stroke();\n      }\n\n      if (particle.close) {\n        context.closePath();\n      }\n\n      if (particle.fill) {\n        context.fill();\n      }\n\n      context.restore();\n      context.save();\n      context.translate(pos.x, pos.y);\n\n      if (angle !== 0) {\n        context.rotate(angle);\n      }\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n      }\n\n      CanvasUtils.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n      context.restore();\n    }\n\n    static drawShape(container, context, particle, radius, opacity, delta) {\n      if (!particle.shape) {\n        return;\n      }\n\n      const drawer = container.drawers.get(particle.shape);\n\n      if (!drawer) {\n        return;\n      }\n\n      drawer.draw(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n    }\n\n    static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n      if (!particle.shape) {\n        return;\n      }\n\n      const drawer = container.drawers.get(particle.shape);\n\n      if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n        return;\n      }\n\n      drawer.afterEffect(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n    }\n\n    static drawPlugin(context, plugin, delta) {\n      if (plugin.draw !== undefined) {\n        context.save();\n        plugin.draw(context, delta);\n        context.restore();\n      }\n    }\n\n  }\n\n  exports.CanvasUtils = CanvasUtils;\n});","map":{"version":3,"sources":["/Users/beetee/Downloads/Bloc/todolist/node_modules/tsparticles/dist/Utils/CanvasUtils.js"],"names":["factory","module","exports","v","require","undefined","define","amd","Object","defineProperty","value","CanvasUtils","ColorUtils_1","NumberUtils_1","drawLine","context","begin","end","beginPath","moveTo","x","y","lineTo","closePath","drawTriangle","p1","p2","p3","paintBase","dimension","baseColor","save","fillStyle","fillRect","width","height","restore","clear","clearRect","drawLinkLine","maxDistance","canvasSize","warp","backgroundMask","composite","colorLine","opacity","shadow","drawn","NumberUtils","getDistance","pi1","pi2","endNE","d1","getDistances","distance","yi","dy","dx","endSW","d2","xi","endSE","d3","lineWidth","globalCompositeOperation","strokeStyle","ColorUtils","getStyleFromRgb","enable","shadowColor","colorToRgb","color","shadowBlur","blur","stroke","drawLinkTriangle","pos1","pos2","pos3","colorTriangle","opacityTriangle","fill","drawConnectLine","lineStyle","gradient","gradStop","Math","floor","getRadius","color1","getFillColor","color2","sourcePos","getPosition","destPos","midRgb","mix","grad","createLinearGradient","addColorStop","getStyleFromHsl","drawGrabLine","drawLight","container","mousePos","lightOptions","options","interactivity","modes","light","area","arc","radius","PI","gradientAmbientLight","createRadialGradient","gradientRgb","start","stop","drawParticleShadow","particle","pos","shadowOptions","sides","full","angle","rotate","factor","dots","i","push","sin","cos","points","shadowLength","length","dot","dotAngle","atan2","endX","endY","startX","startY","shadowRgb","n","drawParticle","delta","fillColorValue","strokeColorValue","translate","particlesOptions","path","pathAngle","shadowOffsetX","offset","shadowOffsetY","strokeWidth","drawShape","close","drawShapeAfterEffect","shape","drawer","drawers","get","draw","retina","pixelRatio","afterEffect","drawPlugin","plugin"],"mappings":"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","sourcesContent":["(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./ColorUtils\", \"./NumberUtils\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.CanvasUtils = void 0;\n    const ColorUtils_1 = require(\"./ColorUtils\");\n    const NumberUtils_1 = require(\"./NumberUtils\");\n    function drawLine(context, begin, end) {\n        context.beginPath();\n        context.moveTo(begin.x, begin.y);\n        context.lineTo(end.x, end.y);\n        context.closePath();\n    }\n    function drawTriangle(context, p1, p2, p3) {\n        context.beginPath();\n        context.moveTo(p1.x, p1.y);\n        context.lineTo(p2.x, p2.y);\n        context.lineTo(p3.x, p3.y);\n        context.closePath();\n    }\n    class CanvasUtils {\n        static paintBase(context, dimension, baseColor) {\n            context.save();\n            context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n            context.fillRect(0, 0, dimension.width, dimension.height);\n            context.restore();\n        }\n        static clear(context, dimension) {\n            context.clearRect(0, 0, dimension.width, dimension.height);\n        }\n        static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n            let drawn = false;\n            if (NumberUtils_1.NumberUtils.getDistance(begin, end) <= maxDistance) {\n                drawLine(context, begin, end);\n                drawn = true;\n            }\n            else if (warp) {\n                let pi1;\n                let pi2;\n                const endNE = {\n                    x: end.x - canvasSize.width,\n                    y: end.y,\n                };\n                const d1 = NumberUtils_1.NumberUtils.getDistances(begin, endNE);\n                if (d1.distance <= maxDistance) {\n                    const yi = begin.y - (d1.dy / d1.dx) * begin.x;\n                    pi1 = { x: 0, y: yi };\n                    pi2 = { x: canvasSize.width, y: yi };\n                }\n                else {\n                    const endSW = {\n                        x: end.x,\n                        y: end.y - canvasSize.height,\n                    };\n                    const d2 = NumberUtils_1.NumberUtils.getDistances(begin, endSW);\n                    if (d2.distance <= maxDistance) {\n                        const yi = begin.y - (d2.dy / d2.dx) * begin.x;\n                        const xi = -yi / (d2.dy / d2.dx);\n                        pi1 = { x: xi, y: 0 };\n                        pi2 = { x: xi, y: canvasSize.height };\n                    }\n                    else {\n                        const endSE = {\n                            x: end.x - canvasSize.width,\n                            y: end.y - canvasSize.height,\n                        };\n                        const d3 = NumberUtils_1.NumberUtils.getDistances(begin, endSE);\n                        if (d3.distance <= maxDistance) {\n                            const yi = begin.y - (d3.dy / d3.dx) * begin.x;\n                            const xi = -yi / (d3.dy / d3.dx);\n                            pi1 = { x: xi, y: yi };\n                            pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };\n                        }\n                    }\n                }\n                if (pi1 && pi2) {\n                    drawLine(context, begin, pi1);\n                    drawLine(context, end, pi2);\n                    drawn = true;\n                }\n            }\n            if (!drawn) {\n                return;\n            }\n            context.lineWidth = width;\n            if (backgroundMask) {\n                context.globalCompositeOperation = composite;\n            }\n            context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n            if (shadow.enable) {\n                const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n                if (shadowColor) {\n                    context.shadowBlur = shadow.blur;\n                    context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n                }\n            }\n            context.stroke();\n        }\n        static drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n            drawTriangle(context, pos1, pos2, pos3);\n            if (backgroundMask) {\n                context.globalCompositeOperation = composite;\n            }\n            context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n            context.fill();\n        }\n        static drawConnectLine(context, width, lineStyle, begin, end) {\n            context.save();\n            drawLine(context, begin, end);\n            context.lineWidth = width;\n            context.strokeStyle = lineStyle;\n            context.stroke();\n            context.restore();\n        }\n        static gradient(context, p1, p2, opacity) {\n            const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n            const color1 = p1.getFillColor();\n            const color2 = p2.getFillColor();\n            if (!color1 || !color2) {\n                return;\n            }\n            const sourcePos = p1.getPosition();\n            const destPos = p2.getPosition();\n            const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.getRadius(), p2.getRadius());\n            const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n            grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n            grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n            grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n            return grad;\n        }\n        static drawGrabLine(context, width, begin, end, colorLine, opacity) {\n            context.save();\n            drawLine(context, begin, end);\n            context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n            context.lineWidth = width;\n            context.stroke();\n            context.restore();\n        }\n        static drawLight(container, context, mousePos) {\n            const lightOptions = container.options.interactivity.modes.light.area;\n            context.beginPath();\n            context.arc(mousePos.x, mousePos.y, lightOptions.radius, 0, 2 * Math.PI);\n            const gradientAmbientLight = context.createRadialGradient(mousePos.x, mousePos.y, 0, mousePos.x, mousePos.y, lightOptions.radius);\n            const gradient = lightOptions.gradient;\n            const gradientRgb = {\n                start: ColorUtils_1.ColorUtils.colorToRgb(gradient.start),\n                stop: ColorUtils_1.ColorUtils.colorToRgb(gradient.stop),\n            };\n            if (!gradientRgb.start || !gradientRgb.stop) {\n                return;\n            }\n            gradientAmbientLight.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.start));\n            gradientAmbientLight.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.stop));\n            context.fillStyle = gradientAmbientLight;\n            context.fill();\n        }\n        static drawParticleShadow(container, context, particle, mousePos) {\n            const pos = particle.getPosition();\n            const shadowOptions = container.options.interactivity.modes.light.shadow;\n            context.save();\n            const radius = particle.getRadius();\n            const sides = particle.sides;\n            const full = (Math.PI * 2) / sides;\n            const angle = -particle.rotate.value + Math.PI / 4;\n            const factor = 1;\n            const dots = [];\n            for (let i = 0; i < sides; i++) {\n                dots.push({\n                    x: pos.x + radius * Math.sin(angle + full * i) * factor,\n                    y: pos.y + radius * Math.cos(angle + full * i) * factor,\n                });\n            }\n            const points = [];\n            const shadowLength = shadowOptions.length;\n            for (const dot of dots) {\n                const dotAngle = Math.atan2(mousePos.y - dot.y, mousePos.x - dot.x);\n                const endX = dot.x + shadowLength * Math.sin(-dotAngle - Math.PI / 2);\n                const endY = dot.y + shadowLength * Math.cos(-dotAngle - Math.PI / 2);\n                points.push({\n                    endX: endX,\n                    endY: endY,\n                    startX: dot.x,\n                    startY: dot.y,\n                });\n            }\n            const shadowRgb = ColorUtils_1.ColorUtils.colorToRgb(shadowOptions.color);\n            if (!shadowRgb) {\n                return;\n            }\n            const shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowRgb);\n            for (let i = points.length - 1; i >= 0; i--) {\n                const n = i == points.length - 1 ? 0 : i + 1;\n                context.beginPath();\n                context.moveTo(points[i].startX, points[i].startY);\n                context.lineTo(points[n].startX, points[n].startY);\n                context.lineTo(points[n].endX, points[n].endY);\n                context.lineTo(points[i].endX, points[i].endY);\n                context.fillStyle = shadowColor;\n                context.fill();\n            }\n            context.restore();\n        }\n        static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow) {\n            const pos = particle.getPosition();\n            context.save();\n            context.translate(pos.x, pos.y);\n            context.beginPath();\n            const angle = particle.rotate.value + (particle.particlesOptions.rotate.path ? particle.pathAngle : 0);\n            if (angle !== 0) {\n                context.rotate(angle);\n            }\n            if (backgroundMask) {\n                context.globalCompositeOperation = composite;\n            }\n            const shadowColor = particle.shadowColor;\n            if (shadow.enable && shadowColor) {\n                context.shadowBlur = shadow.blur;\n                context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n                context.shadowOffsetX = shadow.offset.x;\n                context.shadowOffsetY = shadow.offset.y;\n            }\n            if (fillColorValue) {\n                context.fillStyle = fillColorValue;\n            }\n            const stroke = particle.stroke;\n            context.lineWidth = particle.strokeWidth;\n            if (strokeColorValue) {\n                context.strokeStyle = strokeColorValue;\n            }\n            CanvasUtils.drawShape(container, context, particle, radius, opacity, delta);\n            if (stroke.width > 0) {\n                context.stroke();\n            }\n            if (particle.close) {\n                context.closePath();\n            }\n            if (particle.fill) {\n                context.fill();\n            }\n            context.restore();\n            context.save();\n            context.translate(pos.x, pos.y);\n            if (angle !== 0) {\n                context.rotate(angle);\n            }\n            if (backgroundMask) {\n                context.globalCompositeOperation = composite;\n            }\n            CanvasUtils.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n            context.restore();\n        }\n        static drawShape(container, context, particle, radius, opacity, delta) {\n            if (!particle.shape) {\n                return;\n            }\n            const drawer = container.drawers.get(particle.shape);\n            if (!drawer) {\n                return;\n            }\n            drawer.draw(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n        }\n        static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n            if (!particle.shape) {\n                return;\n            }\n            const drawer = container.drawers.get(particle.shape);\n            if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n                return;\n            }\n            drawer.afterEffect(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n        }\n        static drawPlugin(context, plugin, delta) {\n            if (plugin.draw !== undefined) {\n                context.save();\n                plugin.draw(context, delta);\n                context.restore();\n            }\n        }\n    }\n    exports.CanvasUtils = CanvasUtils;\n});\n"]},"metadata":{},"sourceType":"script"}