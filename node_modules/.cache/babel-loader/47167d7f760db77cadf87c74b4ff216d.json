{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define([\"require\", \"exports\", \"../../Utils\", \"../../Enums\", \"../../Enums/Directions/OutModeDirection\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Updater = void 0;\n\n  const Utils_1 = require(\"../../Utils\");\n\n  const Enums_1 = require(\"../../Enums\");\n\n  const OutModeDirection_1 = require(\"../../Enums/Directions/OutModeDirection\");\n\n  class Updater {\n    constructor(container, particle) {\n      this.container = container;\n      this.particle = particle;\n    }\n\n    update(delta) {\n      if (this.particle.destroyed) {\n        return;\n      }\n\n      this.updateLife(delta);\n\n      if (this.particle.destroyed || this.particle.spawning) {\n        return;\n      }\n\n      this.updateOpacity(delta);\n      this.updateSize(delta);\n      this.updateAngle(delta);\n      this.updateColor(delta);\n      this.updateStrokeColor(delta);\n      this.updateOutModes(delta);\n    }\n\n    updateLife(delta) {\n      const particle = this.particle;\n      let justSpawned = false;\n\n      if (particle.spawning) {\n        particle.lifeDelayTime += delta.value;\n\n        if (particle.lifeDelayTime >= particle.lifeDelay) {\n          justSpawned = true;\n          particle.spawning = false;\n          particle.lifeDelayTime = 0;\n          particle.lifeTime = 0;\n        }\n      }\n\n      if (particle.lifeDuration === -1) {\n        return;\n      }\n\n      if (!particle.spawning) {\n        if (justSpawned) {\n          particle.lifeTime = 0;\n        } else {\n          particle.lifeTime += delta.value;\n        }\n\n        if (particle.lifeTime >= particle.lifeDuration) {\n          particle.lifeTime = 0;\n\n          if (particle.livesRemaining > 0) {\n            particle.livesRemaining--;\n          }\n\n          if (particle.livesRemaining === 0) {\n            particle.destroy();\n            return;\n          }\n\n          const canvasSize = this.container.canvas.size;\n          particle.position.x = Utils_1.NumberUtils.randomInRange(0, canvasSize.width);\n          particle.position.y = Utils_1.NumberUtils.randomInRange(0, canvasSize.height);\n          particle.spawning = true;\n          particle.lifeDelayTime = 0;\n          particle.lifeTime = 0;\n          const lifeOptions = particle.particlesOptions.life;\n          particle.lifeDelay = Utils_1.NumberUtils.getValue(lifeOptions.delay) * 1000;\n          particle.lifeDuration = Utils_1.NumberUtils.getValue(lifeOptions.duration) * 1000;\n        }\n      }\n    }\n\n    updateOpacity(delta) {\n      var _a, _b;\n\n      const particle = this.particle;\n\n      if (particle.particlesOptions.opacity.animation.enable) {\n        switch (particle.opacity.status) {\n          case Enums_1.AnimationStatus.increasing:\n            if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n              particle.opacity.status = Enums_1.AnimationStatus.decreasing;\n            } else {\n              particle.opacity.value += ((_a = particle.opacity.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n            }\n\n            break;\n\n          case Enums_1.AnimationStatus.decreasing:\n            if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n              particle.opacity.status = Enums_1.AnimationStatus.increasing;\n            } else {\n              particle.opacity.value -= ((_b = particle.opacity.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n            }\n\n            break;\n        }\n\n        if (particle.opacity.value < 0) {\n          particle.opacity.value = 0;\n        }\n      }\n    }\n\n    updateSize(delta) {\n      var _a, _b;\n\n      const container = this.container;\n      const particle = this.particle;\n      const sizeOpt = particle.particlesOptions.size;\n      const sizeAnim = sizeOpt.animation;\n      const sizeVelocity = ((_a = particle.size.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n      const maxValue = (_b = particle.sizeValue) !== null && _b !== void 0 ? _b : container.retina.sizeValue;\n      const minValue = sizeAnim.minimumValue * container.retina.pixelRatio;\n\n      if (sizeAnim.enable) {\n        switch (particle.size.status) {\n          case Enums_1.AnimationStatus.increasing:\n            if (particle.size.value >= maxValue) {\n              particle.size.status = Enums_1.AnimationStatus.decreasing;\n            } else {\n              particle.size.value += sizeVelocity;\n            }\n\n            break;\n\n          case Enums_1.AnimationStatus.decreasing:\n            if (particle.size.value <= minValue) {\n              particle.size.status = Enums_1.AnimationStatus.increasing;\n            } else {\n              particle.size.value -= sizeVelocity;\n            }\n\n        }\n\n        switch (sizeAnim.destroy) {\n          case Enums_1.DestroyType.max:\n            if (particle.size.value >= maxValue) {\n              particle.destroy();\n            }\n\n            break;\n\n          case Enums_1.DestroyType.min:\n            if (particle.size.value <= minValue) {\n              particle.destroy();\n            }\n\n            break;\n        }\n\n        if (particle.size.value < 0 && !particle.destroyed) {\n          particle.size.value = 0;\n        }\n      }\n    }\n\n    updateAngle(delta) {\n      var _a;\n\n      const particle = this.particle;\n      const rotate = particle.particlesOptions.rotate;\n      const rotateAnimation = rotate.animation;\n      const speed = ((_a = particle.rotate.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n      const max = 2 * Math.PI;\n\n      if (rotate.path) {\n        particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n      } else if (rotateAnimation.enable) {\n        switch (particle.rotate.status) {\n          case Enums_1.AnimationStatus.increasing:\n            particle.rotate.value += speed;\n\n            if (particle.rotate.value > max) {\n              particle.rotate.value -= max;\n            }\n\n            break;\n\n          case Enums_1.AnimationStatus.decreasing:\n          default:\n            particle.rotate.value -= speed;\n\n            if (particle.rotate.value < 0) {\n              particle.rotate.value += max;\n            }\n\n            break;\n        }\n      }\n    }\n\n    updateColor(delta) {\n      var _a;\n\n      const particle = this.particle;\n\n      if (particle.color.value === undefined) {\n        return;\n      }\n\n      if (particle.particlesOptions.color.animation.enable) {\n        particle.color.value.h += ((_a = particle.color.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n\n        if (particle.color.value.h > 360) {\n          particle.color.value.h -= 360;\n        }\n      }\n    }\n\n    updateStrokeColor(delta) {\n      var _a, _b;\n\n      const particle = this.particle;\n      const color = particle.stroke.color;\n\n      if (typeof color === \"string\" || color === undefined) {\n        return;\n      }\n\n      if (particle.strokeColor.value === undefined) {\n        return;\n      }\n\n      if (color.animation.enable) {\n        particle.strokeColor.value.h += ((_b = (_a = particle.strokeColor.velocity) !== null && _a !== void 0 ? _a : particle.color.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n\n        if (particle.strokeColor.value.h > 360) {\n          particle.strokeColor.value.h -= 360;\n        }\n      }\n    }\n\n    updateOutModes(delta) {\n      var _a, _b, _c, _d;\n\n      const outModes = this.particle.particlesOptions.move.outModes;\n      this.updateOutMode(delta, (_a = outModes.bottom) !== null && _a !== void 0 ? _a : outModes.default, OutModeDirection_1.OutModeDirection.bottom);\n      this.updateOutMode(delta, (_b = outModes.left) !== null && _b !== void 0 ? _b : outModes.default, OutModeDirection_1.OutModeDirection.left);\n      this.updateOutMode(delta, (_c = outModes.right) !== null && _c !== void 0 ? _c : outModes.default, OutModeDirection_1.OutModeDirection.right);\n      this.updateOutMode(delta, (_d = outModes.top) !== null && _d !== void 0 ? _d : outModes.default, OutModeDirection_1.OutModeDirection.top);\n    }\n\n    updateOutMode(delta, outMode, direction) {\n      const container = this.container;\n      const particle = this.particle;\n      const gravityOptions = particle.particlesOptions.move.gravity;\n\n      switch (outMode) {\n        case Enums_1.OutMode.bounce:\n        case Enums_1.OutMode.bounceVertical:\n        case Enums_1.OutMode.bounceHorizontal:\n        case \"bounceVertical\":\n        case \"bounceHorizontal\":\n          this.updateBounce(delta, direction, outMode);\n          break;\n\n        case Enums_1.OutMode.destroy:\n          if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n            container.particles.remove(particle);\n          }\n\n          break;\n\n        case Enums_1.OutMode.out:\n          if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n            this.fixOutOfCanvasPosition(direction);\n          }\n\n          break;\n\n        case Enums_1.OutMode.none:\n          if (particle.particlesOptions.move.distance) {\n            return;\n          }\n\n          if (!gravityOptions.enable) {\n            if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n              container.particles.remove(particle);\n            }\n          } else {\n            const position = particle.position;\n\n            if (gravityOptions.acceleration >= 0 && position.y > container.canvas.size.height && direction === OutModeDirection_1.OutModeDirection.bottom || gravityOptions.acceleration < 0 && position.y < 0 && direction === OutModeDirection_1.OutModeDirection.top) {\n              container.particles.remove(particle);\n            }\n          }\n\n          break;\n      }\n    }\n\n    fixOutOfCanvasPosition(direction) {\n      const container = this.container;\n      const particle = this.particle;\n      const wrap = particle.particlesOptions.move.warp;\n      const canvasSize = container.canvas.size;\n      const newPos = {\n        bottom: canvasSize.height + particle.getRadius() - particle.offset.y,\n        left: -particle.getRadius() - particle.offset.x,\n        right: canvasSize.width + particle.getRadius() + particle.offset.x,\n        top: -particle.getRadius() - particle.offset.y\n      };\n      const sizeValue = particle.getRadius();\n      const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n\n      if (direction === OutModeDirection_1.OutModeDirection.right && nextBounds.left > canvasSize.width - particle.offset.x) {\n        particle.position.x = newPos.left;\n\n        if (!wrap) {\n          particle.position.y = Math.random() * canvasSize.height;\n        }\n      } else if (direction === OutModeDirection_1.OutModeDirection.left && nextBounds.right < -particle.offset.x) {\n        particle.position.x = newPos.right;\n\n        if (!wrap) {\n          particle.position.y = Math.random() * canvasSize.height;\n        }\n      }\n\n      if (direction === OutModeDirection_1.OutModeDirection.bottom && nextBounds.top > canvasSize.height - particle.offset.y) {\n        if (!wrap) {\n          particle.position.x = Math.random() * canvasSize.width;\n        }\n\n        particle.position.y = newPos.top;\n      } else if (direction === OutModeDirection_1.OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {\n        if (!wrap) {\n          particle.position.x = Math.random() * canvasSize.width;\n        }\n\n        particle.position.y = newPos.bottom;\n      }\n    }\n\n    updateBounce(delta, direction, outMode) {\n      const container = this.container;\n      const particle = this.particle;\n      let handled = false;\n\n      for (const [, plugin] of container.plugins) {\n        if (plugin.particleBounce !== undefined) {\n          handled = plugin.particleBounce(particle, delta, direction);\n        }\n\n        if (handled) {\n          break;\n        }\n      }\n\n      if (handled) {\n        return;\n      }\n\n      const pos = particle.getPosition(),\n            offset = particle.offset,\n            size = particle.getRadius(),\n            bounds = Utils_1.Utils.calculateBounds(pos, size),\n            canvasSize = container.canvas.size;\n\n      if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal || outMode === \"bounceHorizontal\") {\n        const velocity = particle.velocity.horizontal;\n        let bounced = false;\n\n        if (direction === OutModeDirection_1.OutModeDirection.right && bounds.right >= canvasSize.width && velocity > 0 || direction === OutModeDirection_1.OutModeDirection.left && bounds.left <= 0 && velocity < 0) {\n          const newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.horizontal);\n          particle.velocity.horizontal *= -newVelocity;\n          bounced = true;\n        }\n\n        if (bounced) {\n          const minPos = offset.x + size;\n\n          if (bounds.right >= canvasSize.width) {\n            particle.position.x = canvasSize.width - minPos;\n          } else if (bounds.left <= 0) {\n            particle.position.x = minPos;\n          }\n        }\n      }\n\n      if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical || outMode === \"bounceVertical\") {\n        const velocity = particle.velocity.vertical;\n        let bounced = false;\n\n        if (direction === OutModeDirection_1.OutModeDirection.bottom && bounds.bottom >= container.canvas.size.height && velocity > 0 || direction === OutModeDirection_1.OutModeDirection.top && bounds.top <= 0 && velocity < 0) {\n          const newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.vertical);\n          particle.velocity.vertical *= -newVelocity;\n          bounced = true;\n        }\n\n        if (bounced) {\n          const minPos = offset.y + size;\n\n          if (bounds.bottom >= canvasSize.height) {\n            particle.position.y = canvasSize.height - minPos;\n          } else if (bounds.top <= 0) {\n            particle.position.y = minPos;\n          }\n        }\n      }\n    }\n\n  }\n\n  exports.Updater = Updater;\n});","map":{"version":3,"sources":["/Users/beetee/Downloads/Bloc/todolist/node_modules/tsparticles/dist/Core/Particle/Updater.js"],"names":["factory","module","exports","v","require","undefined","define","amd","Object","defineProperty","value","Updater","Utils_1","Enums_1","OutModeDirection_1","constructor","container","particle","update","delta","destroyed","updateLife","spawning","updateOpacity","updateSize","updateAngle","updateColor","updateStrokeColor","updateOutModes","justSpawned","lifeDelayTime","lifeDelay","lifeTime","lifeDuration","livesRemaining","destroy","canvasSize","canvas","size","position","x","NumberUtils","randomInRange","width","y","height","lifeOptions","particlesOptions","life","getValue","delay","duration","_a","_b","opacity","animation","enable","status","AnimationStatus","increasing","decreasing","velocity","factor","minimumValue","sizeOpt","sizeAnim","sizeVelocity","maxValue","sizeValue","retina","minValue","pixelRatio","DestroyType","max","min","rotate","rotateAnimation","speed","Math","PI","path","pathAngle","atan2","vertical","horizontal","color","h","stroke","strokeColor","_c","_d","outModes","move","updateOutMode","bottom","default","OutModeDirection","left","right","top","outMode","direction","gravityOptions","gravity","OutMode","bounce","bounceVertical","bounceHorizontal","updateBounce","Utils","isPointInside","getRadius","particles","remove","out","fixOutOfCanvasPosition","none","distance","acceleration","wrap","warp","newPos","offset","nextBounds","calculateBounds","random","handled","plugin","plugins","particleBounce","pos","getPosition","bounds","bounced","newVelocity","minPos"],"mappings":"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","sourcesContent":["(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../../Utils\", \"../../Enums\", \"../../Enums/Directions/OutModeDirection\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Updater = void 0;\n    const Utils_1 = require(\"../../Utils\");\n    const Enums_1 = require(\"../../Enums\");\n    const OutModeDirection_1 = require(\"../../Enums/Directions/OutModeDirection\");\n    class Updater {\n        constructor(container, particle) {\n            this.container = container;\n            this.particle = particle;\n        }\n        update(delta) {\n            if (this.particle.destroyed) {\n                return;\n            }\n            this.updateLife(delta);\n            if (this.particle.destroyed || this.particle.spawning) {\n                return;\n            }\n            this.updateOpacity(delta);\n            this.updateSize(delta);\n            this.updateAngle(delta);\n            this.updateColor(delta);\n            this.updateStrokeColor(delta);\n            this.updateOutModes(delta);\n        }\n        updateLife(delta) {\n            const particle = this.particle;\n            let justSpawned = false;\n            if (particle.spawning) {\n                particle.lifeDelayTime += delta.value;\n                if (particle.lifeDelayTime >= particle.lifeDelay) {\n                    justSpawned = true;\n                    particle.spawning = false;\n                    particle.lifeDelayTime = 0;\n                    particle.lifeTime = 0;\n                }\n            }\n            if (particle.lifeDuration === -1) {\n                return;\n            }\n            if (!particle.spawning) {\n                if (justSpawned) {\n                    particle.lifeTime = 0;\n                }\n                else {\n                    particle.lifeTime += delta.value;\n                }\n                if (particle.lifeTime >= particle.lifeDuration) {\n                    particle.lifeTime = 0;\n                    if (particle.livesRemaining > 0) {\n                        particle.livesRemaining--;\n                    }\n                    if (particle.livesRemaining === 0) {\n                        particle.destroy();\n                        return;\n                    }\n                    const canvasSize = this.container.canvas.size;\n                    particle.position.x = Utils_1.NumberUtils.randomInRange(0, canvasSize.width);\n                    particle.position.y = Utils_1.NumberUtils.randomInRange(0, canvasSize.height);\n                    particle.spawning = true;\n                    particle.lifeDelayTime = 0;\n                    particle.lifeTime = 0;\n                    const lifeOptions = particle.particlesOptions.life;\n                    particle.lifeDelay = Utils_1.NumberUtils.getValue(lifeOptions.delay) * 1000;\n                    particle.lifeDuration = Utils_1.NumberUtils.getValue(lifeOptions.duration) * 1000;\n                }\n            }\n        }\n        updateOpacity(delta) {\n            var _a, _b;\n            const particle = this.particle;\n            if (particle.particlesOptions.opacity.animation.enable) {\n                switch (particle.opacity.status) {\n                    case Enums_1.AnimationStatus.increasing:\n                        if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n                            particle.opacity.status = Enums_1.AnimationStatus.decreasing;\n                        }\n                        else {\n                            particle.opacity.value += ((_a = particle.opacity.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n                        }\n                        break;\n                    case Enums_1.AnimationStatus.decreasing:\n                        if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n                            particle.opacity.status = Enums_1.AnimationStatus.increasing;\n                        }\n                        else {\n                            particle.opacity.value -= ((_b = particle.opacity.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n                        }\n                        break;\n                }\n                if (particle.opacity.value < 0) {\n                    particle.opacity.value = 0;\n                }\n            }\n        }\n        updateSize(delta) {\n            var _a, _b;\n            const container = this.container;\n            const particle = this.particle;\n            const sizeOpt = particle.particlesOptions.size;\n            const sizeAnim = sizeOpt.animation;\n            const sizeVelocity = ((_a = particle.size.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n            const maxValue = (_b = particle.sizeValue) !== null && _b !== void 0 ? _b : container.retina.sizeValue;\n            const minValue = sizeAnim.minimumValue * container.retina.pixelRatio;\n            if (sizeAnim.enable) {\n                switch (particle.size.status) {\n                    case Enums_1.AnimationStatus.increasing:\n                        if (particle.size.value >= maxValue) {\n                            particle.size.status = Enums_1.AnimationStatus.decreasing;\n                        }\n                        else {\n                            particle.size.value += sizeVelocity;\n                        }\n                        break;\n                    case Enums_1.AnimationStatus.decreasing:\n                        if (particle.size.value <= minValue) {\n                            particle.size.status = Enums_1.AnimationStatus.increasing;\n                        }\n                        else {\n                            particle.size.value -= sizeVelocity;\n                        }\n                }\n                switch (sizeAnim.destroy) {\n                    case Enums_1.DestroyType.max:\n                        if (particle.size.value >= maxValue) {\n                            particle.destroy();\n                        }\n                        break;\n                    case Enums_1.DestroyType.min:\n                        if (particle.size.value <= minValue) {\n                            particle.destroy();\n                        }\n                        break;\n                }\n                if (particle.size.value < 0 && !particle.destroyed) {\n                    particle.size.value = 0;\n                }\n            }\n        }\n        updateAngle(delta) {\n            var _a;\n            const particle = this.particle;\n            const rotate = particle.particlesOptions.rotate;\n            const rotateAnimation = rotate.animation;\n            const speed = ((_a = particle.rotate.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n            const max = 2 * Math.PI;\n            if (rotate.path) {\n                particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n            }\n            else if (rotateAnimation.enable) {\n                switch (particle.rotate.status) {\n                    case Enums_1.AnimationStatus.increasing:\n                        particle.rotate.value += speed;\n                        if (particle.rotate.value > max) {\n                            particle.rotate.value -= max;\n                        }\n                        break;\n                    case Enums_1.AnimationStatus.decreasing:\n                    default:\n                        particle.rotate.value -= speed;\n                        if (particle.rotate.value < 0) {\n                            particle.rotate.value += max;\n                        }\n                        break;\n                }\n            }\n        }\n        updateColor(delta) {\n            var _a;\n            const particle = this.particle;\n            if (particle.color.value === undefined) {\n                return;\n            }\n            if (particle.particlesOptions.color.animation.enable) {\n                particle.color.value.h += ((_a = particle.color.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n                if (particle.color.value.h > 360) {\n                    particle.color.value.h -= 360;\n                }\n            }\n        }\n        updateStrokeColor(delta) {\n            var _a, _b;\n            const particle = this.particle;\n            const color = particle.stroke.color;\n            if (typeof color === \"string\" || color === undefined) {\n                return;\n            }\n            if (particle.strokeColor.value === undefined) {\n                return;\n            }\n            if (color.animation.enable) {\n                particle.strokeColor.value.h +=\n                    ((_b = (_a = particle.strokeColor.velocity) !== null && _a !== void 0 ? _a : particle.color.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n                if (particle.strokeColor.value.h > 360) {\n                    particle.strokeColor.value.h -= 360;\n                }\n            }\n        }\n        updateOutModes(delta) {\n            var _a, _b, _c, _d;\n            const outModes = this.particle.particlesOptions.move.outModes;\n            this.updateOutMode(delta, (_a = outModes.bottom) !== null && _a !== void 0 ? _a : outModes.default, OutModeDirection_1.OutModeDirection.bottom);\n            this.updateOutMode(delta, (_b = outModes.left) !== null && _b !== void 0 ? _b : outModes.default, OutModeDirection_1.OutModeDirection.left);\n            this.updateOutMode(delta, (_c = outModes.right) !== null && _c !== void 0 ? _c : outModes.default, OutModeDirection_1.OutModeDirection.right);\n            this.updateOutMode(delta, (_d = outModes.top) !== null && _d !== void 0 ? _d : outModes.default, OutModeDirection_1.OutModeDirection.top);\n        }\n        updateOutMode(delta, outMode, direction) {\n            const container = this.container;\n            const particle = this.particle;\n            const gravityOptions = particle.particlesOptions.move.gravity;\n            switch (outMode) {\n                case Enums_1.OutMode.bounce:\n                case Enums_1.OutMode.bounceVertical:\n                case Enums_1.OutMode.bounceHorizontal:\n                case \"bounceVertical\":\n                case \"bounceHorizontal\":\n                    this.updateBounce(delta, direction, outMode);\n                    break;\n                case Enums_1.OutMode.destroy:\n                    if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n                        container.particles.remove(particle);\n                    }\n                    break;\n                case Enums_1.OutMode.out:\n                    if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n                        this.fixOutOfCanvasPosition(direction);\n                    }\n                    break;\n                case Enums_1.OutMode.none:\n                    if (particle.particlesOptions.move.distance) {\n                        return;\n                    }\n                    if (!gravityOptions.enable) {\n                        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n                            container.particles.remove(particle);\n                        }\n                    }\n                    else {\n                        const position = particle.position;\n                        if ((gravityOptions.acceleration >= 0 &&\n                            position.y > container.canvas.size.height &&\n                            direction === OutModeDirection_1.OutModeDirection.bottom) ||\n                            (gravityOptions.acceleration < 0 && position.y < 0 && direction === OutModeDirection_1.OutModeDirection.top)) {\n                            container.particles.remove(particle);\n                        }\n                    }\n                    break;\n            }\n        }\n        fixOutOfCanvasPosition(direction) {\n            const container = this.container;\n            const particle = this.particle;\n            const wrap = particle.particlesOptions.move.warp;\n            const canvasSize = container.canvas.size;\n            const newPos = {\n                bottom: canvasSize.height + particle.getRadius() - particle.offset.y,\n                left: -particle.getRadius() - particle.offset.x,\n                right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                top: -particle.getRadius() - particle.offset.y,\n            };\n            const sizeValue = particle.getRadius();\n            const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n            if (direction === OutModeDirection_1.OutModeDirection.right && nextBounds.left > canvasSize.width - particle.offset.x) {\n                particle.position.x = newPos.left;\n                if (!wrap) {\n                    particle.position.y = Math.random() * canvasSize.height;\n                }\n            }\n            else if (direction === OutModeDirection_1.OutModeDirection.left && nextBounds.right < -particle.offset.x) {\n                particle.position.x = newPos.right;\n                if (!wrap) {\n                    particle.position.y = Math.random() * canvasSize.height;\n                }\n            }\n            if (direction === OutModeDirection_1.OutModeDirection.bottom && nextBounds.top > canvasSize.height - particle.offset.y) {\n                if (!wrap) {\n                    particle.position.x = Math.random() * canvasSize.width;\n                }\n                particle.position.y = newPos.top;\n            }\n            else if (direction === OutModeDirection_1.OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {\n                if (!wrap) {\n                    particle.position.x = Math.random() * canvasSize.width;\n                }\n                particle.position.y = newPos.bottom;\n            }\n        }\n        updateBounce(delta, direction, outMode) {\n            const container = this.container;\n            const particle = this.particle;\n            let handled = false;\n            for (const [, plugin] of container.plugins) {\n                if (plugin.particleBounce !== undefined) {\n                    handled = plugin.particleBounce(particle, delta, direction);\n                }\n                if (handled) {\n                    break;\n                }\n            }\n            if (handled) {\n                return;\n            }\n            const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = Utils_1.Utils.calculateBounds(pos, size), canvasSize = container.canvas.size;\n            if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal || outMode === \"bounceHorizontal\") {\n                const velocity = particle.velocity.horizontal;\n                let bounced = false;\n                if ((direction === OutModeDirection_1.OutModeDirection.right && bounds.right >= canvasSize.width && velocity > 0) ||\n                    (direction === OutModeDirection_1.OutModeDirection.left && bounds.left <= 0 && velocity < 0)) {\n                    const newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.horizontal);\n                    particle.velocity.horizontal *= -newVelocity;\n                    bounced = true;\n                }\n                if (bounced) {\n                    const minPos = offset.x + size;\n                    if (bounds.right >= canvasSize.width) {\n                        particle.position.x = canvasSize.width - minPos;\n                    }\n                    else if (bounds.left <= 0) {\n                        particle.position.x = minPos;\n                    }\n                }\n            }\n            if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical || outMode === \"bounceVertical\") {\n                const velocity = particle.velocity.vertical;\n                let bounced = false;\n                if ((direction === OutModeDirection_1.OutModeDirection.bottom &&\n                    bounds.bottom >= container.canvas.size.height &&\n                    velocity > 0) ||\n                    (direction === OutModeDirection_1.OutModeDirection.top && bounds.top <= 0 && velocity < 0)) {\n                    const newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.vertical);\n                    particle.velocity.vertical *= -newVelocity;\n                    bounced = true;\n                }\n                if (bounced) {\n                    const minPos = offset.y + size;\n                    if (bounds.bottom >= canvasSize.height) {\n                        particle.position.y = canvasSize.height - minPos;\n                    }\n                    else if (bounds.top <= 0) {\n                        particle.position.y = minPos;\n                    }\n                }\n            }\n        }\n    }\n    exports.Updater = Updater;\n});\n"]},"metadata":{},"sourceType":"script"}